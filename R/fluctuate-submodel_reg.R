#' Fit Logistic Regression to Traverse the Fluctuation Submodel
#'
#' @param Y A \code{numeric} vector corresponding to an outcome variable.
#' @param Qn_scaled An object providing the value of the outcome evaluated after
#'  imposing a shift in the treatment. This object should be passed in after
#'  being constructed by a call to the internal function \code{est_Q}.
#' @param Hn An object providing values of the auxiliary ("clever") covariate,
#'  constructed from the treatment mechanism and required for targeted minimum
#'  loss-based estimation. This object object should be passed in after being
#'  constructed by a call to the internal function \code{est_Hn}.
#' @param ipc_weights A \code{numeric} vector that gives inverse probability of
#'  censoring weights for each observation. These are generated by invoking the
#'  routines for estimating the censoring mechanism.
#' @param method A \code{character} giving the type of regression to be used in
#'  traversing the fluctuation sub-model. Choices are "weighted" and "standard".
#'  Please consult the literature for details on the differences.
#'
#' @importFrom stats qlogis glm fitted predict as.formula
#' @importFrom data.table as.data.table setnames
#' @importFrom dplyr "%>%"
#'
#' @keywords internal
#
fit_fluc <- function(Y,
                     Qn_scaled,
                     Hn,
                     ipc_weights = rep(1, length(Y)),
                     method = c("standard", "weighted")) {

  # scale the outcome for the logit transform
  y_star <- bound_scaling(
    Y = Y,
    scale_target = Y,
    scale_type = "bound_in_01"
  )

  # extract Q and obtain logit transform
  logit_Qn <- stats::qlogis(Qn_scaled$noshift)

  # fit the fluctuation regression in one of two ways
  if (method == "standard") {
    # note that \epsilon_n will be the coefficient of the covariate Hn
    suppressWarnings(
      mod_fluc <- stats::glm(
        formula = stats::as.formula(
          "y_star ~ -1 + offset(logit_Qn) + Hn"
        ),
        weights = ipc_weights,
        data = data.table::as.data.table(list(
          y_star = y_star,
          logit_Qn = logit_Qn,
          Hn = Hn$noshift
        )),
        family = "binomial"
      )
    )
  } else if (method == "weighted") {
    # note that \epsilon_n will be the intercept term here
    suppressWarnings(
      mod_fluc <- stats::glm(
        formula = stats::as.formula("y_star ~ offset(logit_Qn)"),
        data = data.table::as.data.table(list(
          y_star = y_star,
          logit_Qn = logit_Qn
        )),
        weights = as.numeric(Hn$noshift * ipc_weights),
        family = "binomial"
      )
    )
  }

  # get fitted values from fluctuation model
  Qn_noshift_star_pred <- stats::fitted(mod_fluc) %>%
    as.numeric()
  Qn_noshift_star <- bound_scaling(
    Y = Y,
    pred_vals = Qn_noshift_star_pred,
    scale_target = Qn_noshift_star_pred,
    scale_type = "observed_vals"
  )

  # need to logit transform Qn(d(A,W),W)
  Qn_shift_logit <- stats::qlogis(Qn_scaled$upshift)

  # get Qn_star for the SHIFTED data
  if (method == "standard") {
    Qn_shift_star_in <- data.table::as.data.table(list(
      logit_Qn = Qn_shift_logit,
      Hn = Hn$shift
    ))

    # predict from fluctuation model on Q(d(A,W),W) and Hn(d(A,W))
    Qn_shift_star_pred <- stats::predict(
      object = mod_fluc,
      newdata = Qn_shift_star_in,
      type = "response"
    ) %>%
      as.numeric()
  } else if (method == "weighted") {
    Qn_shift_star_in <- data.table::as.data.table(Qn_shift_logit)
    data.table::setnames(Qn_shift_star_in, "logit_Qn")

    # predict from fluctuation model on Q(d(A,W),W)
    Qn_shift_star_pred <- stats::predict(
      object = mod_fluc,
      newdata = Qn_shift_star_in,
      type = "response"
    ) %>%
      as.numeric()
  }

  Qn_shift_star <- bound_scaling(
    Y = Y,
    pred_vals = Qn_shift_star_pred,
    scale_target = Qn_shift_star_pred,
    scale_type = "observed_vals"
  )

  # return the fit model object
  out <- list(
    fluc_fit = mod_fluc,
    covar_method = method,
    Qn_shift_star = as.numeric(Qn_shift_star),
    Qn_noshift_star = as.numeric(Qn_noshift_star)
  )
  return(out)
}
