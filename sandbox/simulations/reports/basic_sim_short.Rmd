---
title: "Basic Simulations for Targeted Learning in Stochastic Treatment Regimes"
author: "Nima Hejazi and David Benkeser"
date: "`r Sys.Date()`"
output: html_document
---

```{r rmd_setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(here)
library(sl3)
library(condensier)
library(shifttx)
```

### Compute TMLE for a single iteration of simulations

```{r sim_fun}
simple_shifttx_sim <- function(iter, samp, delta = 0.5,
                               n_w, w1_prob, a1_mean, a0_mean,
                               fit_type = "sl",
                               glm_form = "Y ~ .",
                               sl_lrnrs = c("mean", "glm_fast"),
                               sl_meta = "nnls") {

  if ((iter %% 100) == 0) {
    print(paste("Starting simulation", iter, "for sample size", samp))
  }

  ## baseline covariate -- simple, binary
  W <- as.numeric(replicate(n_w, rbinom(samp, 1, w1_prob)))

  ## set and organize treatment based on baseline W
  A1 <- rnorm(length(which(W == 1)), mean = a1_mean, sd = 1)
  A0 <- rnorm(length(which(W == 0)), mean = a0_mean, sd = 1)
  A <- rep(NA, samp)
  A[which(W == 0)] <- A0
  A[which(W == 1)] <- A1

  # create outcome
  Y <- A + W + rnorm(samp)

  # compute the truth from the simulation
  # \Psi(P_0) = E_0( \bar{Q}_0(A + \delta, W))
  #   = E_0(A + \delta + W)  -> definition of \bar{Q}_0
  #   = E_0(E_0(A \mid W) + \delta + W)  -> iterated expectation
  #   = \delta + P(W = 0) * (E_0(A \mid W = 0) + 0)
  #     + P(W = 1) * (E_0(A \mid W = 1) + 1)  -> defn of expectation over W
  #   = 0.5 + 0.5 * (0 + 0) + 0.5 * (2 + 1)
  #   = 2
  sim_truth = delta + (1 - w1_prob) * (a0_mean + 0) + w1_prob * (a1_mean + 1)

  # do a TMLE
  tmle_shift <- tmle_shifttx(W = W, A = A, Y = Y, delta = delta,
                             g_fit_args = list(nbins = 20,
                                               bin_method = "dhist",
                                               bin_estimator =
                                                 speedglmR6$new(),
                                               parfit = FALSE),
                             Q_fit_args = list(fit_method = fit_type,
                                               glm_formula = glm_form,
                                               sl_learners = sl_lrnrs,
                                               sl_metalearner = sl_meta),
                             fluc_method = "standard",
                             eif_tol = 1e-7
                            )
  ci_shift <- confint(tmle_shift)

  # summary statistics from TMLE procedure
  point_est <- tmle_shift$psi
  ci_in <- as.numeric(between(sim_truth, ci_shift[1], ci_shift[3]))
  sim_iter_out <- c(ci_shift[1], point_est, ci_shift[3], ci_in, sim_truth)
  names(sim_iter_out) <- c("lwr_ci", "est_psi", "upr_ci", "truth_in_ci",
                           "truth")
  sim_iter_out <- as.data.frame(t(as.matrix(sim_iter_out)))
  return(sim_iter_out)
}
```

### Set up parameters for parallelized simulations

```{r sim_args}
library(future)
library(doFuture)
registerDoFuture()

# parameters for simulating simple data for tmle-shift sketch
n_w <- 1
w_win_prob <- 0.5
a1_mean <- 2
a0_mean <- 0
delta_shift <- 0.5

# meta-parameters for controlling simulation type
seed_int <- 9461287
n_sim <- 500
n_obs <- c(100, 1000)
```

### Fitting outcome model with GLMs

```{r run_sim_glm, message = FALSE}
# simulation
simple_sim_glm <- foreach(samp_it = seq_along(n_obs), .combine = rbind) %do% {
  # set sample size from foreach loop
  samp <- n_obs[samp_it]

  # run simulation for given sample size
  sim_results <- foreach(i = seq_len(n_sim),
                         .combine = rbind) %dopar% {
    # set seed in foreach
    set.seed(seed_int + i)

    # run the TMLE procedure
    out <- simple_shifttx_sim(iter = i, samp = samp, delta = delta_shift,
                              n_w = n_w, w1_prob = w_win_prob,
                              a1_mean = a1_mean, a0_mean = a0_mean,
                              fit_type = "glm",
                              glm_form = "Y ~ .")
    out
  }
  # compute average estimate, bias, and sd across simulations
  sim_point_est <- mean(sim_results$est_psi)
  sim_est_var <- var(sim_results$est_psi)
  sim_est_bias <- sim_point_est - mean(sim_results$truth)
  sim_ci_cover <- sum(sim_results$truth_in_ci) / nrow(sim_results)
  sim_out <- c(samp, sim_point_est, sim_est_var, sim_est_bias, sim_ci_cover)
  names(sim_out) <- c("n_size", "est", "var", "bias", "coverage")
  sim_samp_out <- as.data.frame(t(as.matrix(sim_out)))
  sim_samp_out
}

knitr::kable(simple_sim_glm, format = "markdown")
```

### Fitting outcome model with Super Learner

```{r run_sim_sl, message = FALSE}
# simulation
simple_sim_sl <- foreach(samp_it = seq_along(n_obs), .combine = rbind) %do% {
  # set sample size from foreach loop
  samp <- n_obs[samp_it]

  # run simulation for given sample size
  sim_results <- foreach(i = seq_len(n_sim),
                         .combine = rbind) %dopar% {
    # set seed in foreach
    set.seed(seed_int + i)

    # run the TMLE procedure
    out <- simple_shifttx_sim(iter = i, samp = samp, delta = delta_shift,
                              n_w = n_w, w1_prob = w_win_prob,
                              a1_mean = a1_mean, a0_mean = a0_mean,
                              fit_type = "sl",
                              sl_lrnrs = c("mean", "glm_fast", "randomForest"),
                              sl_meta = "nnls")
    out
  }
  # compute average estimate, bias, and sd across simulations
  sim_point_est <- mean(sim_results$est_psi)
  sim_est_var <- var(sim_results$est_psi)
  sim_est_bias <- sim_point_est - mean(sim_results$truth)
  sim_ci_cover <- sum(sim_results$truth_in_ci) / nrow(sim_results)
  sim_out <- c(samp, sim_point_est, sim_est_var, sim_est_bias, sim_ci_cover)
  names(sim_out) <- c("n_size", "est", "var", "bias", "coverage")
  sim_samp_out <- as.data.frame(t(as.matrix(sim_out)))
  sim_samp_out
}

knitr::kable(simple_sim_sl, format = "markdown")
```

